<?php

/**
 * @file
 * Uninstall exp bundles, install du bundles .
 */

use Drupal\Core\Entity\EntityDefinitionUpdateManagerInterface;
use Drupal\Core\Entity\Schema\EntityStorageSchemaInterface;
use Drupal\Core\Field\FieldStorageDefinitionInterface;

/**
 * Implements hook_update_N().
 *
 * Remove landing page type if it exists, remove panels and dep modules.
 */
function du_site_update_8002(&$sandbox) {
  $landing_page_ctype = \Drupal::service('entity_type.manager')
    ->getStorage('node_type')
    ->load('landing_page');
  if ($landing_page_ctype) {
    $landing_page_ctype->delete();
  }
  \Drupal::service('module_installer')->uninstall(['panels']);
}

/**
 * Implements hook_update_N().
 *
 * Uninstall features that do not have custom code.
 */
function du_site_update_8003(&$sandbox) {
  $features_to_remove = [
    'du_application_information',
    'du_base_config',
    'du_base_roles',
    'du_base_taxonomy',
    'du_base_workflow',
    'du_core_content_types',
    'du_core_navigation',
    'du_core_site_config',
    'du_course',
    'du_example_unit_views',
    'du_featured_courses',
    'du_mini_event_calendar',
    'du_newsroom',
    'du_shared_content',
    'du_unit_block',
    'du_unit_carousel',
    'du_unit_content_types',
    'du_unit_navigation',
    'du_unit_taxonomy',
    'features_ui',
    'features',
  ];

  // Remove modules that are not enabled.
  $moduleHandler = \Drupal::service('module_handler');
  foreach ($features_to_remove as $key => $module) {
    if (!$moduleHandler->moduleExists($module)) {
      unset($features_to_remove[$key]);
    }
  }

  // Disable features.
  if (!empty($features_to_remove)) {
    \Drupal::service('module_installer')->uninstall($features_to_remove, FALSE);
  }
}

/**
 * Implements hook_update_N().
 *
 * Clear caches after moving modules.
 */
function du_site_update_8004(&$sandbox) {
  drupal_flush_all_caches();
}

/**
 * Implements hook_update_N().
 *
 * Switch sites to Cludo Search.
 */
function du_site_update_8005(&$sandbox) {
  // Import config to disable du_search and google_appliance.
  drush_invoke_process('@self', 'csim');

  // Set cludo path to 'search'.
  $config = \Drupal::configFactory()->getEditable('cludo_search.settings');
  $config->set('search_page', 'search');
  $config->save();

  // Refresh cludo search settings getter.
  _cludo_search_get_settings(TRUE);

  // Delete search utility page(s).
  $result = \Drupal::entityQuery('node')
    ->accessCheck(TRUE)
    ->condition('type', 'utility_page')
    ->condition('title', 'Search')
    ->execute();

  $storage_handler = \Drupal::entityTypeManager()->getStorage('node');
  $entities = $storage_handler->loadMultiple($result);
  $storage_handler->delete($entities);

  // Rebuild registry.
  \Drupal::service('router.builder')->rebuild();

  // Clear cache.
  drupal_flush_all_caches();
}

/**
 * Implements hook_update_N().
 *
 * Migrate site_navigation entity fields to appropriate menu items.
 */
function du_site_update_8006() {
  $navs = \Drupal::entityTypeManager()->getStorage('site_navigation')->loadMultiple();
  foreach ($navs as $nav) {
    // We only want nav_pane entities.
    if ($nav->bundle() != 'nav_pane') {
      continue;
    }

    // Get the menu item that the site navigation links to.
    $menu_item = $nav->get('field_parent_menu_item')->entity;
    if (!empty($menu_item)) {
      // Set as expanded if the nav pane doesn't have "Show Parent Item Only"
      // checked.
      if (empty($nav->get('field_parent_item_only')->value)) {
        $menu_item->expanded = TRUE;
      }
      $menu_item->field_nav_headline = $nav->field_nav_headline;
      $menu_item->field_nav_description = $nav->field_nav_description;
      $menu_item->field_nav_image = $nav->field_nav_image;
      $menu_item->field_nav_button = $nav->field_nav_button;
      $menu_item->save();
    }
  }
}

/**
 * Implements hook_update_N().
 *
 * Delete existing events imported from ACH.
 */
function du_site_update_8007(&$sandbox) {
  $module_handler = \Drupal::moduleHandler();
  $nids = [];

  if ($module_handler->moduleExists('acquia_contenthub')) {
    // Handle one pass through.
    $query = \Drupal::database()
      ->select('node', 'n');
    $query->join('acquia_contenthub_entities_tracking', 'ach', 'n.uuid = ach.entity_uuid');
    $query->fields('n', ['nid' => 'nid'])
      ->condition('n.type', 'event')
      ->condition('ach.status_import', 'AUTO_UPDATE_ENABLED')
      ->range(0, 25);
    $results = $query->execute()->fetchAllAssoc('nid');
    $nids = array_keys($results);

    if (count($nids) > 0) {
      $contentLock = NULL;
      $storage_handler = \Drupal::entityTypeManager()->getStorage('node');
      $entities = $storage_handler->loadMultiple($nids);

      // Load the content lock service if it exists.
      if ($module_handler->moduleExists('content_lock')) {
        $contentLock = \Drupal::service('content_lock');
      }

      foreach ($entities as $node) {
        if ($contentLock) {
          $contentLock->release($node->id(), $node->language);
        }
        $node->delete();
      }
    }
  }

  // If there are not 25 nodes, assume all have been deleted.
  if (count($nids) >= 25) {
    $sandbox['#finished'] = 0;
  }
  else {
    $sandbox['#finished'] = 1;
  }
}

/**
 * Implements hook_update_N().
 */
function du_site_update_8008() {
  $result = \Drupal::entityQuery('taxonomy_term')
    ->accessCheck(TRUE)
    ->condition('vid', 'tags')
    ->execute();
  \Drupal::entityTypeManager()->getStorage('taxonomy_term')->delete($result);
}

/**
 * Implements hook_update_N().
 *
 * Update bibcite_reference title field.
 */
function du_site_update_8009() {
  // Manually update the storage definitions so that it contains the correct 510
  // length for the title field.
  $db = \Drupal::database();
  $data = $db->query("select value from key_value where collection = 'entity.definitions.installed' and name = 'bibcite_reference.field_storage_definitions'")->fetchCol();
  $data = preg_replace('/i:255;/', 'i:510;', $data[0], 1);
  $query = $db->update('key_value');
  $query->fields(['value' => $data]);
  $query->condition('collection', 'entity.definitions.installed');
  $query->condition('name', 'bibcite_reference.field_storage_definitions');
  $query->execute();

  // Update the storage schema.
  $key_value = \Drupal::keyValue('entity.storage_schema.sql');
  $key_name = 'bibcite_reference.field_schema_data.title';
  $storage_schema = $key_value->get($key_name);

  // Update all tables where the field is present.
  foreach ($storage_schema as &$table_schema) {
    $table_schema['fields']['title']['length'] = 510;
  }
  $key_value->set($key_name, $storage_schema);

  // Update the database tables where the field is part of.
  $db = Drupal::database();
  foreach ($storage_schema as $table_name => $table_schema) {
    $db->schema()->changeField($table_name, 'title', 'title', $table_schema['fields']['title']);
  }
}

/**
 * Implements hook_update_N().
 *
 * Update bibcite_reference csl style field.
 */
function du_site_update_8010() {
  // Update the storage schema.
  $key_value = \Drupal::keyValue('entity.storage_schema.sql');
  $key_name = 'bibcite_reference.field_schema_data.field_csl_style';
  $storage_schema = $key_value->get($key_name);
  $db_schema = \Drupal::database()->schema();

  // If there is no storage schema stored in the key_value table but the
  // database table exists for the field, we need to manually add the schema
  // data.
  if (empty($storage_schema) && $db_schema->tableExists('bibcite_reference__field_csl_style')) {
    $schema = unserialize('a:1:{s:34:"bibcite_reference__field_csl_style";a:4:{s:11:"description";s:57:"Data storage for bibcite_reference field field_csl_style.";s:6:"fields";a:7:{s:6:"bundle";a:5:{s:4:"type";s:13:"varchar_ascii";s:6:"length";i:128;s:8:"not null";b:1;s:7:"default";s:0:"";s:11:"description";s:88:"The field instance bundle to which this row belongs, used when deleting a field instance";}s:7:"deleted";a:5:{s:4:"type";s:3:"int";s:4:"size";s:4:"tiny";s:8:"not null";b:1;s:7:"default";i:0;s:11:"description";s:60:"A boolean indicating whether this data item has been deleted";}s:9:"entity_id";a:4:{s:4:"type";s:3:"int";s:8:"unsigned";b:1;s:8:"not null";b:1;s:11:"description";s:38:"The entity id this data is attached to";}s:11:"revision_id";a:4:{s:4:"type";s:3:"int";s:8:"unsigned";b:1;s:8:"not null";b:1;s:11:"description";s:114:"The entity revision id this data is attached to, which for an unversioned entity type is the same as the entity id";}s:8:"langcode";a:5:{s:4:"type";s:13:"varchar_ascii";s:6:"length";i:32;s:8:"not null";b:1;s:7:"default";s:0:"";s:11:"description";s:37:"The language code for this data item.";}s:5:"delta";a:4:{s:4:"type";s:3:"int";s:8:"unsigned";b:1;s:8:"not null";b:1;s:11:"description";s:67:"The sequence number for this data item, used for multi-value fields";}s:21:"field_csl_style_value";a:4:{s:4:"type";s:7:"varchar";s:6:"length";i:255;s:6:"binary";b:0;s:8:"not null";b:1;}}s:11:"primary key";a:4:{i:0;s:9:"entity_id";i:1;s:7:"deleted";i:2;s:5:"delta";i:3;s:8:"langcode";}s:7:"indexes";a:2:{s:6:"bundle";a:1:{i:0;s:6:"bundle";}s:11:"revision_id";a:1:{i:0;s:11:"revision_id";}}}}');
    $key_value->set($key_name, $schema);
  }
}

/**
 * Implements hook_update_N().
 *
 * Update paragraph menu reference tab menu field.
 */
function du_site_update_8011() {
  // Update the storage schema.
  $key_value = \Drupal::keyValue('entity.storage_schema.sql');
  $key_name = 'paragraph.field_schema_data.field_menu_reference_tab_menu';
  $storage_schema = $key_value->get($key_name);

  // Update the database tables where the field is part of.
  $db = Drupal::database();
  foreach ($storage_schema as $table_name => &$table_schema) {
    if ($table_schema['fields']['field_menu_reference_tab_menu_target_id']['length'] != 32) {
      $table_schema['fields']['field_menu_reference_tab_menu_target_id']['length'] = 32;
      $db->schema()->changeField($table_name, 'field_menu_reference_tab_menu_target_id', 'field_menu_reference_tab_menu_target_id', $table_schema['fields']['field_menu_reference_tab_menu_target_id']);
    }
  }

  // Update the key value storage.
  $key_value->set($key_name, $storage_schema);
}

/**
 * Implements hook_update_N().
 */
function du_site_update_8012() {
  // Replicates the old 'drush entup' functionality. Fields and entities that
  // need created/updated/deleted will be processed here.
  $entityDefinitionUpdateManager = \Drupal::service('entity.definition_update_manager');
  $entityTypeManager = \Drupal::service('entity_type.manager');
  $entityFieldManager = \Drupal::service('entity_field.manager');
  $entityLastInstalledSchemaRepository = \Drupal::service('entity.last_installed_schema.repository');

  $complete_change_list = $entityDefinitionUpdateManager->getChangeList();

  if ($complete_change_list) {
    // EntityDefinitionUpdateManagerInterface::getChangeList() only disables
    // the cache and does not invalidate. In case there are changes,
    // explicitly invalidate caches.
    $entityTypeManager->clearCachedDefinitions();
    $entityFieldManager->clearCachedFieldDefinitions();
  }
  foreach ($complete_change_list as $entity_type_id => $change_list) {
    if ($entity_type_id == 'bibcite_reference') {
      continue;
    }
    // Process entity type definition changes before storage definitions ones
    // this is necessary when you change an entity type from non-revisionable
    // to revisionable and at the same time add revisionable fields to the
    // entity type.
    if (!empty($change_list['entity_type'])) {
      du_site_do_entity_update($change_list['entity_type'], $entity_type_id);
    }

    // Process field storage definition changes.
    if (!empty($change_list['field_storage_definitions'])) {
      $storage_definitions = $entityFieldManager->getFieldStorageDefinitions($entity_type_id);
      $original_storage_definitions = $entityLastInstalledSchemaRepository->getLastInstalledFieldStorageDefinitions($entity_type_id);

      foreach ($change_list['field_storage_definitions'] as $field_name => $change) {
        $storage_definition = isset($storage_definitions[$field_name]) ? $storage_definitions[$field_name] : NULL;
        $original_storage_definition = isset($original_storage_definitions[$field_name]) ? $original_storage_definitions[$field_name] : NULL;
        du_site_do_field_update($change, $storage_definition, $original_storage_definition);
      }
    }
  }
}

/**
 * Performs an entity type definition update.
 *
 * @param string $op
 *   The operation to perform, either static::DEFINITION_CREATED or
 *   static::DEFINITION_UPDATED.
 * @param string $entity_type_id
 *   The entity type ID.
 */
function du_site_do_entity_update($op, $entity_type_id) {
  $entityTypeManager = \Drupal::service('entity_type.manager');
  $entityTypeListener = \Drupal::service('entity_type.listener');
  $entityFieldManager = \Drupal::service('entity_field.manager');
  $entityLastInstalledSchemaRepository = \Drupal::service('entity.last_installed_schema.repository');

  $entity_type = $entityTypeManager->getDefinition($entity_type_id);
  switch ($op) {
    case EntityDefinitionUpdateManagerInterface::DEFINITION_CREATED:
      $entityTypeListener->onEntityTypeCreate($entity_type);
      break;

    case EntityDefinitionUpdateManagerInterface::DEFINITION_UPDATED:
      $original = $entityLastInstalledSchemaRepository->getLastInstalledDefinition($entity_type_id);
      $storage = $entityTypeManager->getStorage($entity_type->id());
      if ($storage instanceof EntityStorageSchemaInterface && $storage->requiresEntityDataMigration($entity_type, $original)) {
        throw new \InvalidArgumentException('The entity schema update for the ' . $entity_type->id() . ' entity type requires a data migration.');
      }
      $field_storage_definitions = $entityFieldManager->getFieldStorageDefinitions($entity_type_id);
      $original_field_Storage_definitions = $entityLastInstalledSchemaRepository->getLastInstalledFieldStorageDefinitions($entity_type_id);
      $entityTypeListener->onFieldableEntityTypeUpdate($entity_type, $original, $field_storage_definitions, $original_field_Storage_definitions);

      break;
  }
}

/**
 * Performs a field storage definition update.
 *
 * @param string $op
 *   The operation to perform.
 * @param \Drupal\Core\Field\FieldStorageDefinitionInterface|null $storage_definition
 *   (optional) The new field storage definition. Defaults to none.
 * @param \Drupal\Core\Field\FieldStorageDefinitionInterface|null $original_storage_definition
 *   (optional) The original field storage definition. Defaults to none.
 */
function du_site_do_field_update($op, FieldStorageDefinitionInterface $storage_definition = NULL, FieldStorageDefinitionInterface $original_storage_definition = NULL) {
  $fieldStorageDefinitionListener = \Drupal::service('field_storage_definition.listener');

  switch ($op) {
    case EntityDefinitionUpdateManagerInterface::DEFINITION_CREATED:
      $this->fieldStorageDefinitionListener->onFieldStorageDefinitionCreate($storage_definition);
      break;

    case EntityDefinitionUpdateManagerInterface::DEFINITION_UPDATED:
      if ($storage_definition && $original_storage_definition) {
        $fieldStorageDefinitionListener->onFieldStorageDefinitionUpdate($storage_definition, $original_storage_definition);
      }
      break;

    case EntityDefinitionUpdateManagerInterface::DEFINITION_DELETED:
      if ($original_storage_definition) {
        $fieldStorageDefinitionListener->onFieldStorageDefinitionDelete($original_storage_definition);
      }
      break;
  }
}

/**
 * Implements hook_update_N().
 */
function du_site_update_8013() {
  // Remove du_subnav_block module from the database to prevent warnings when
  // running drush commands.
  $query = \Drupal::database()->delete('key_value');
  $query->condition('collection', 'system.schema');
  $query->condition('name', 'du_subnav_block');
  $query->execute();
}

/**
 * Delete bibcite_contributor entities.
 *
 * This is just to handle upgrading bibcite from 1.0-alpha10 to 1.x-dev for D9
 * readiness. The update hooks to get there wouldn't work, so this is an easier
 * way to get the module upgraded.
 */
function du_site_update_8014(&$sandbox) {
  $nids = [];
  $entity = 'bibcite_contributor';

  if (\Drupal::moduleHandler()->moduleExists('bibcite')) {
    $nids = \Drupal::entityQuery($entity)->range(0, 50)->execute();
    entity_delete_multiple($entity, $nids);
  }

  // If there are not 50 nodes, assume all have been deleted.
  if (count($nids) >= 50) {
    $sandbox['#finished'] = 0;
  }
  else {
    $sandbox['#finished'] = 1;
  }
}

/**
 * Delete bibcite_keyword entities.
 *
 * This is just to handle upgrading bibcite from 1.0-alpha10 to 1.x-dev for D9
 * readiness. The update hooks to get there wouldn't work, so this is an easier
 * way to get the module upgraded.
 */
function du_site_update_8015(&$sandbox) {
  $nids = [];
  $entity = 'bibcite_keyword';

  if (\Drupal::moduleHandler()->moduleExists('bibcite')) {
    $nids = \Drupal::entityQuery($entity)->range(0, 50)->execute();
    entity_delete_multiple($entity, $nids);
  }

  // If there are not 50 nodes, assume all have been deleted.
  if (count($nids) >= 50) {
    $sandbox['#finished'] = 0;
  }
  else {
    $sandbox['#finished'] = 1;
  }
}

/**
 * Delete bibcite_reference entities.
 *
 * This is just to handle upgrading bibcite from 1.0-alpha10 to 1.x-dev for D9
 * readiness. The update hooks to get there wouldn't work, so this is an easier
 * way to get the module upgraded.
 */
function du_site_update_8016(&$sandbox) {
  $nids = [];
  $entity = 'bibcite_reference';

  if (\Drupal::moduleHandler()->moduleExists('bibcite')) {
    $nids = \Drupal::entityQuery($entity)->range(0, 50)->execute();
    entity_delete_multiple($entity, $nids);
  }

  // If there are not 50 nodes, assume all have been deleted.
  if (count($nids) >= 50) {
    $sandbox['#finished'] = 0;
  }
  else {
    $sandbox['#finished'] = 1;
  }
}

/**
 * Remove deleted fields tables if there are no deleted fields known about.
 */
function du_site_update_8017() {
  $deleted_fields_repository = \Drupal::service('entity_field.deleted_fields_repository');
  $fields = $deleted_fields_repository->getFieldDefinitions($field_storage_unique_id);

  if (empty($fields)) {
    $database = \Drupal::database();
    $tables = $database->query("SHOW tables LIKE 'field_deleted_%'")->fetchCol();
    if (!empty($tables)) {
      foreach ($tables as $table) {
        $database->schema()->dropTable($table);
      }
    }
  }
}

/**
 * Uninstall bibcite module.
 */
function du_site_update_8018() {
  \Drupal::service('module_installer')->uninstall(['bibcite']);
}

/**
 * Implements hook_update_N().
 *
 * Check path aliases and set auto generate.
 */
function du_site_update_8020(&$sandbox) {
  if (\Drupal::moduleHandler()->moduleExists('cms_content_sync')) {
    $nogo_urls = [
      'http://dev-content1.pantheonsite.io',
      'https://dev-content1.pantheonsite.io',
      'http://test-content1.pantheonsite.io',
      'https://test-content1.pantheonsite.io',
      'http://live-content1.pantheonsite.io',
      'https://live-content1.pantheonsite.io',
      'http://content.du.edu',
      'https://content.du.edu',
      'http://local.content.com',
    ];
    if (!empty($GLOBALS['base_url']) && !in_array($GLOBALS['base_url'], $nogo_urls)) {
      if (!isset($sandbox['types'])) {
        $sandbox['range'] = [0, 25];
        $sandbox['types'] = [
          'profile',
        ];
      }
      $nids = \Drupal::entityQuery('node')
        ->accessCheck(TRUE)
        ->condition('type', $sandbox['types'], 'IN')
        ->condition('status', 1)
        ->range($sandbox['range'][0], $sandbox['range'][1])
        ->sort('nid')
        ->execute();

      if (!empty($nids)) {
        $nodes = \Drupal::entityTypeManager()->getStorage('node')->loadMultiple($nids);

        foreach ($nodes as $node) {
          $node->set('path', ['pathauto' => 1, 'alias' => NULL]);
          $node->save();
        }

        $sandbox['range'][0] += 25;
        $sandbox['#finished'] = 0;
      }
      else {
        $sandbox['#finished'] = 1;
      }
    }
  }
}
